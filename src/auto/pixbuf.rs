// This file was generated by gir (d8a605d) from gir-files (469db10)
// DO NOT EDIT

use Colorspace;
use Error;
use PixbufFormat;
use ffi;
#[cfg(any(feature = "v2_32", feature = "dox"))]
use gio;
#[cfg(any(feature = "v2_32", feature = "dox"))]
use gio_ffi;
use glib;
use glib::StaticType;
use glib::Value;
use glib::object::Downcast;
use glib::object::IsA;
use glib::signal::SignalHandlerId;
use glib::signal::connect;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::boxed::Box as Box_;
use std::mem;
use std::mem::transmute;
use std::ptr;

glib_wrapper! {
    pub struct Pixbuf(Object<ffi::GdkPixbuf>);

    match fn {
        get_type => || ffi::gdk_pixbuf_get_type(),
    }
}

impl Pixbuf {
    pub fn new(colorspace: Colorspace, has_alpha: bool, bits_per_sample: i32, width: i32, height: i32) -> Pixbuf {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new(colorspace.to_glib(), has_alpha.to_glib(), bits_per_sample, width, height))
        }
    }

    #[cfg(any(feature = "v2_32", feature = "dox"))]
    pub fn new_from_bytes(data: &glib::Bytes, colorspace: Colorspace, has_alpha: bool, bits_per_sample: i32, width: i32, height: i32, rowstride: i32) -> Pixbuf {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new_from_bytes(data.to_glib_none().0, colorspace.to_glib(), has_alpha.to_glib(), bits_per_sample, width, height, rowstride))
        }
    }

    //pub fn new_from_data<'a, P: Into<Option<&'a /*Unimplemented*/PixbufDestroyNotify>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(data: &[u8], colorspace: Colorspace, has_alpha: bool, bits_per_sample: i32, width: i32, height: i32, rowstride: i32, destroy_fn: P, destroy_fn_data: Q) -> Pixbuf {
    //    unsafe { TODO: call ffi::gdk_pixbuf_new_from_data() }
    //}

    pub fn new_from_inline(data: &[u8], copy_pixels: bool) -> Result<Pixbuf, Error> {
        let data_length = data.len() as i32;
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_inline(data_length, data.to_glib_none().0, copy_pixels.to_glib(), &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    pub fn new_from_resource(resource_path: &str) -> Result<Pixbuf, Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_resource(resource_path.to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    pub fn new_from_resource_at_scale(resource_path: &str, width: i32, height: i32, preserve_aspect_ratio: bool) -> Result<Pixbuf, Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::gdk_pixbuf_new_from_resource_at_scale(resource_path.to_glib_none().0, width, height, preserve_aspect_ratio.to_glib(), &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    //pub fn new_from_stream<'a, P: IsA</*Ignored*/gio::InputStream>, Q: Into<Option<&'a gio::Cancellable>>>(stream: &P, cancellable: Q) -> Result<Pixbuf, Error> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_new_from_stream() }
    //}

    //pub fn new_from_stream_at_scale<'a, P: IsA</*Ignored*/gio::InputStream>, Q: Into<Option<&'a gio::Cancellable>>>(stream: &P, width: i32, height: i32, preserve_aspect_ratio: bool, cancellable: Q) -> Result<Pixbuf, Error> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_new_from_stream_at_scale() }
    //}

    pub fn new_from_xpm_data(data: &[&str]) -> Pixbuf {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new_from_xpm_data(data.to_glib_none().0))
        }
    }

    //pub fn from_pixdata(pixdata: /*Ignored*/&Pixdata, copy_pixels: bool) -> Result<Pixbuf, Error> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_from_pixdata() }
    //}

    pub fn get_file_info(filename: &str) -> (Option<PixbufFormat>, i32, i32) {
        unsafe {
            let mut width = mem::uninitialized();
            let mut height = mem::uninitialized();
            let ret = from_glib_none(ffi::gdk_pixbuf_get_file_info(filename.to_glib_none().0, &mut width, &mut height));
            (ret, width, height)
        }
    }

    #[cfg(any(feature = "v2_32", feature = "dox"))]
    pub fn get_file_info_async<'a, P: Into<Option<&'a gio::Cancellable>>, Q: Fn(Result<(i32, i32), Error>) + Send + Sync + 'static>(filename: &str, cancellable: P, callback: Q) {
        let cancellable = cancellable.into();
        let cancellable = cancellable.to_glib_none();
        let user_data: Box<Box<Fn(Result<(i32, i32), Error>) + Send + Sync + 'static>> = Box::new(Box::new(callback));
        extern "C" fn get_file_info_async_trampoline(_source_object: *mut gobject_ffi::GObject, res: *mut gio_ffi::GAsyncResult, user_data: glib_ffi::gpointer)
        {
            callback_guard!();
            unsafe {
                let mut error = ptr::null_mut();
                let mut width = mem::uninitialized();
                let mut height = mem::uninitialized();
                let _ = ffi::gdk_pixbuf_get_file_info_finish(res, &mut width, &mut height, &mut error);
                let result = if error.is_null() { Ok((width, height)) } else { Err(from_glib_full(error)) };
                let callback: &&(Fn(Result<(i32, i32), Error>) + Send + Sync + 'static) = transmute(user_data);
                callback(result);
            }
        }
        let callback = get_file_info_async_trampoline;
        unsafe {
            ffi::gdk_pixbuf_get_file_info_async(filename.to_glib_none().0, cancellable.0, Some(callback), Box::into_raw(user_data) as *mut _);
        }
    }

    pub fn get_formats() -> Vec<PixbufFormat> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gdk_pixbuf_get_formats())
        }
    }

    //pub fn new_from_stream_async<'a, P: IsA</*Ignored*/gio::InputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: Fn(Result<(), Error>) + Send + Sync + 'static>(stream: &P, cancellable: Q, callback: R) {
    //    unsafe { TODO: call ffi::gdk_pixbuf_new_from_stream_async() }
    //}

    //pub fn new_from_stream_at_scale_async<'a, P: IsA</*Ignored*/gio::InputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: /*Ignored*/gio::AsyncReadyCallback>(stream: &P, width: i32, height: i32, preserve_aspect_ratio: bool, cancellable: Q, callback: R) {
    //    unsafe { TODO: call ffi::gdk_pixbuf_new_from_stream_at_scale_async() }
    //}
}

pub trait PixbufExt {
    fn apply_embedded_orientation(&self) -> Option<Pixbuf>;

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn copy_options(&self, dest_pixbuf: &Pixbuf) -> bool;

    fn fill(&self, pixel: u32);

    fn get_option(&self, key: &str) -> Option<String>;

    //#[cfg(any(feature = "v2_32", feature = "dox"))]
    //fn get_options(&self) -> /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 };

    fn new_subpixbuf(&self, src_x: i32, src_y: i32, width: i32, height: i32) -> Option<Pixbuf>;

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn remove_option(&self, key: &str) -> bool;

    //fn save<'a, P: Into<Option<&'a Error>>>(&self, filename: &str, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool;

    //fn save_to_buffer<'a, P: Into<Option<&'a Error>>>(&self, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Vec<u8>>;

    fn save_to_bufferv(&self, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<Vec<u8>, Error>;

    //fn save_to_callback<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a Error>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, error: Q, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool;

    //fn save_to_callbackv<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<(), Error>;

    //fn save_to_stream<'a, 'b, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: Into<Option<&'b Error>>>(&self, stream: &P, type_: &str, cancellable: Q, error: R, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool;

    //fn save_to_stream_async<'a, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: Fn(Result<(), Error>) + Send + Sync + 'static>(&self, stream: &P, type_: &str, cancellable: Q, callback: R, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs);

    //#[cfg(any(feature = "v2_36", feature = "dox"))]
    //fn save_to_streamv<'a, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>>(&self, stream: &P, type_: &str, option_keys: &[&str], option_values: &[&str], cancellable: Q) -> Result<(), Error>;

    //#[cfg(any(feature = "v2_36", feature = "dox"))]
    //fn save_to_streamv_async<'a, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: /*Ignored*/gio::AsyncReadyCallback>(&self, stream: &P, type_: &str, option_keys: &[&str], option_values: &[&str], cancellable: Q, callback: R);

    fn savev(&self, filename: &str, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<(), Error>;

    fn set_option(&self, key: &str, value: &str) -> bool;

    fn get_property_bits_per_sample(&self) -> i32;

    fn get_property_colorspace(&self) -> Colorspace;

    fn get_property_has_alpha(&self) -> bool;

    fn get_property_height(&self) -> i32;

    fn get_property_n_channels(&self) -> i32;

    fn get_property_pixel_bytes(&self) -> Option<glib::Bytes>;

    //fn get_property_pixels(&self) -> /*Unimplemented*/Fundamental: Pointer;

    fn get_property_rowstride(&self) -> i32;

    fn get_property_width(&self) -> i32;

    fn connect_property_bits_per_sample_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_colorspace_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_has_alpha_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_n_channels_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_pixel_bytes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_pixels_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_rowstride_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Pixbuf> + IsA<glib::object::Object>> PixbufExt for O {
    fn apply_embedded_orientation(&self) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_apply_embedded_orientation(self.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn copy_options(&self, dest_pixbuf: &Pixbuf) -> bool {
        unsafe {
            from_glib(ffi::gdk_pixbuf_copy_options(self.to_glib_none().0, dest_pixbuf.to_glib_none().0))
        }
    }

    fn fill(&self, pixel: u32) {
        unsafe {
            ffi::gdk_pixbuf_fill(self.to_glib_none().0, pixel);
        }
    }

    fn get_option(&self, key: &str) -> Option<String> {
        unsafe {
            from_glib_none(ffi::gdk_pixbuf_get_option(self.to_glib_none().0, key.to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v2_32", feature = "dox"))]
    //fn get_options(&self) -> /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 } {
    //    unsafe { TODO: call ffi::gdk_pixbuf_get_options() }
    //}

    fn new_subpixbuf(&self, src_x: i32, src_y: i32, width: i32, height: i32) -> Option<Pixbuf> {
        unsafe {
            from_glib_full(ffi::gdk_pixbuf_new_subpixbuf(self.to_glib_none().0, src_x, src_y, width, height))
        }
    }

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    fn remove_option(&self, key: &str) -> bool {
        unsafe {
            from_glib(ffi::gdk_pixbuf_remove_option(self.to_glib_none().0, key.to_glib_none().0))
        }
    }

    //fn save<'a, P: Into<Option<&'a Error>>>(&self, filename: &str, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save() }
    //}

    //fn save_to_buffer<'a, P: Into<Option<&'a Error>>>(&self, type_: &str, error: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<Vec<u8>> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_buffer() }
    //}

    fn save_to_bufferv(&self, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<Vec<u8>, Error> {
        unsafe {
            let mut buffer = ptr::null_mut();
            let mut buffer_size = mem::uninitialized();
            let mut error = ptr::null_mut();
            let _ = ffi::gdk_pixbuf_save_to_bufferv(self.to_glib_none().0, &mut buffer, &mut buffer_size, type_.to_glib_none().0, option_keys.to_glib_none().0, option_values.to_glib_none().0, &mut error);
            if error.is_null() { Ok(FromGlibContainer::from_glib_full_num(buffer, buffer_size as usize)) } else { Err(from_glib_full(error)) }
        }
    }

    //fn save_to_callback<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a Error>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, error: Q, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_callback() }
    //}

    //fn save_to_callbackv<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(&self, save_func: /*Unknown conversion*//*Unimplemented*/PixbufSaveFunc, user_data: P, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<(), Error> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_callbackv() }
    //}

    //fn save_to_stream<'a, 'b, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: Into<Option<&'b Error>>>(&self, stream: &P, type_: &str, cancellable: Q, error: R, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_stream() }
    //}

    //fn save_to_stream_async<'a, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: Fn(Result<(), Error>) + Send + Sync + 'static>(&self, stream: &P, type_: &str, cancellable: Q, callback: R, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_stream_async() }
    //}

    //#[cfg(any(feature = "v2_36", feature = "dox"))]
    //fn save_to_streamv<'a, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>>(&self, stream: &P, type_: &str, option_keys: &[&str], option_values: &[&str], cancellable: Q) -> Result<(), Error> {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_streamv() }
    //}

    //#[cfg(any(feature = "v2_36", feature = "dox"))]
    //fn save_to_streamv_async<'a, P: IsA</*Ignored*/gio::OutputStream>, Q: Into<Option<&'a gio::Cancellable>>, R: /*Ignored*/gio::AsyncReadyCallback>(&self, stream: &P, type_: &str, option_keys: &[&str], option_values: &[&str], cancellable: Q, callback: R) {
    //    unsafe { TODO: call ffi::gdk_pixbuf_save_to_streamv_async() }
    //}

    fn savev(&self, filename: &str, type_: &str, option_keys: &[&str], option_values: &[&str]) -> Result<(), Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ffi::gdk_pixbuf_savev(self.to_glib_none().0, filename.to_glib_none().0, type_.to_glib_none().0, option_keys.to_glib_none().0, option_values.to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    fn set_option(&self, key: &str, value: &str) -> bool {
        unsafe {
            from_glib(ffi::gdk_pixbuf_set_option(self.to_glib_none().0, key.to_glib_none().0, value.to_glib_none().0))
        }
    }

    fn get_property_bits_per_sample(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "bits-per-sample".to_glib_none().0, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_colorspace(&self) -> Colorspace {
        unsafe {
            let mut value = Value::from_type(<Colorspace as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "colorspace".to_glib_none().0, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_has_alpha(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "has-alpha".to_glib_none().0, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_height(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "height".to_glib_none().0, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_n_channels(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "n-channels".to_glib_none().0, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_pixel_bytes(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "pixel-bytes".to_glib_none().0, value.to_glib_none_mut().0);
            value.get()
        }
    }

    //fn get_property_pixels(&self) -> /*Unimplemented*/Fundamental: Pointer {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_ffi::g_object_get_property(self.to_glib_none().0, "pixels".to_glib_none().0, value.to_glib_none_mut().0);
    //        value.get().unwrap()
    //    }
    //}

    fn get_property_rowstride(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "rowstride".to_glib_none().0, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_width(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "width".to_glib_none().0, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn connect_property_bits_per_sample_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::bits-per-sample",
                transmute(notify_bits_per_sample_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_colorspace_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::colorspace",
                transmute(notify_colorspace_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_has_alpha_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::has-alpha",
                transmute(notify_has_alpha_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::height",
                transmute(notify_height_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_n_channels_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::n-channels",
                transmute(notify_n_channels_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_pixel_bytes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::pixel-bytes",
                transmute(notify_pixel_bytes_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_pixels_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::pixels",
                transmute(notify_pixels_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_rowstride_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::rowstride",
                transmute(notify_rowstride_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }

    fn connect_property_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe {
            let f: Box_<Box_<Fn(&Self) + 'static>> = Box_::new(Box_::new(f));
            connect(self.to_glib_none().0, "notify::width",
                transmute(notify_width_trampoline::<Self> as usize), Box_::into_raw(f) as *mut _)
        }
    }
}

unsafe extern "C" fn notify_bits_per_sample_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_colorspace_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_has_alpha_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_height_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_n_channels_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_pixel_bytes_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_pixels_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_rowstride_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}

unsafe extern "C" fn notify_width_trampoline<P>(this: *mut ffi::GdkPixbuf, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<Pixbuf> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Pixbuf::from_glib_borrow(this).downcast_unchecked())
}
